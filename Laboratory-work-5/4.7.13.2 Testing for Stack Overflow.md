# Тестування для переповнення стека

Переповнення стека відбувається, коли дані змінного розміру копіюються в буфери фіксованої довжини, розташовані в стеку програми, без будь-якої перевірки меж. Уразливості цього класу зазвичай вважаються дуже серйозними, оскільки їх використання здебільшого допускає виконання довільного коду або відмову в обслуговуванні. Рідко зустрічається в інтерпретованих платформах, код, написаний на C та подібних мовах, часто містить екземпляри цієї вразливості. Насправді майже кожна платформа вразлива до переповнень стека за наступними помітними винятками:

J2EE – поки не викликаються власні методи або системні виклики
.NET – поки /unsafe або некерований код не викликається (наприклад, використання P/Invoke або COM Interop)
PHP – доки зовнішні програми та вразливі розширення PHP, написані на C або C++, не викликаються, можуть мати проблеми з переповненням стека.
Уразливості переповнення стека часто дозволяють зловмиснику безпосередньо контролювати покажчик інструкцій і, отже, змінювати виконання програми та виконувати довільний код. Крім перезапису вказівника інструкції, подібні результати також можна отримати шляхом перезапису інших змінних і структур, таких як обробники винятків, які розташовані в стеку.

Як тестувати
Тестування чорної скриньки
Ключ до перевірки програми на вразливості переповнення стека полягає в надсиланні надто великих вхідних даних порівняно з очікуваними. Однак підпорядкування програми довільно великим обсягом даних недостатньо. Необхідно перевірити потік виконання програми та відповіді, щоб переконатися, чи справді було запущено переповнення чи ні. Таким чином, кроки, необхідні для визначення місцезнаходження та перевірки переповнення стеку, полягають у приєднанні налагоджувача до цільової програми або процесу, генеруванні неправильного введення для програми, підпорядкуванні програми неправильному введенню та перевірці відповідей у налагоджувачі. Налагоджувач дозволяє тестувальнику переглядати потік виконання та стан реєстрів, коли вразливість спрацьовує.

З іншого боку, можна застосувати більш пасивну форму тестування, яка передбачає перевірку коду складання програми за допомогою дизассемблерів. У цьому випадку різні розділи скануються на наявність сигнатур уразливих фрагментів збірки. Це часто називають зворотним проектуванням і є виснажливим процесом.

Як простий приклад розглянемо наступну техніку, застосовану під час тестування виконуваного файлу «sample.exe» на предмет переповнення стеку:

#include<stdio.h>
int main(int argc, char *argv[])
{
    char buff[20];
    printf("copying into buffer");
    strcpy(buff,argv[1]);
    return 0;
}

Оскільки програма очікує аргументів командного рядка, у показаному вище полі аргументу можна вказати велику послідовність символів, наприклад «A».

Після відкриття виконуваного файлу з наданими аргументами та продовження виконання отримано наступні результати.

Як показано у вікні реєстрів налагоджувача, EIP або покажчик розширеної інструкції, який вказує на наступну інструкцію, яку потрібно виконати, містить значення 41414141. 41 є шістнадцятковим представленням символу A, тому рядок AAAA перетворюється на 41414141.

Це чітко демонструє, як вхідні дані можна використовувати для перезапису вказівника інструкції значеннями, наданими користувачем, і керування виконанням програми. Переповнення стека також може дозволити перезапис структур на основі стека, таких як SEH (обробник структурованих винятків), щоб контролювати виконання коду та обходити певні механізми захисту стека.

Як згадувалося раніше, інші методи тестування таких уразливостей включають зворотне проектування двійкових файлів програми, що є складним і виснажливим процесом, і використання методів фаззингу.

# Тестування Gray-Box
Переглядаючи код на наявність переповнень стека, доцільно шукати виклики незахищених бібліотечних функцій, таких як gets(), strcpy(), strcat() тощо, які не перевіряють довжину вихідних рядків і сліпо копіюють дані в буфери фіксованого розміру.

Для прикладу розглянемо таку функцію:

void log_create(int severity, char *inpt) {

char b[1024];

if (severity == 1)
{
strcat(b,”Error occurred on”);
strcat(b,":");
strcat(b,inpt);


FILE *fd = fopen ("logfile.log", "a");
fprintf(fd, "%s", b);
fclose(fd);

. . . . . .
}

Зверху рядок strcat(b,inpt) призведе до переповнення стека, якщо inpt перевищує 1024 байти. Це не тільки демонструє небезпечне використання strcat, але також показує, наскільки важливо перевіряти довжину рядків, на які посилається вказівник символів, який передається як аргумент функції; У цьому випадку довжина рядка, на який посилається char *inpt. Тому під час перегляду коду завжди доцільно відстежувати джерело аргументів функції та з’ясовувати довжину рядків.

Використання відносно безпечнішого strncpy() також може призвести до переповнення стеку, оскільки він обмежує лише кількість байтів, скопійованих у буфер призначення. Якщо аргумент розміру, який використовується для цього, генерується динамічно на основі введення користувача або обчислюється неточно в циклах, можливо переповнення буферів стека. Наприклад:

void func(char *source)
{
Char dest[40];
…
size=strlen(source)+1
….
strncpy(dest,source,size)
}

де джерелом є дані, якими керує користувач. Хорошим прикладом може бути вразливість samba trans2open, що створює переповнення стеку.

Уразливості також можуть виявлятися в коді аналізу URL-адреси та адреси. У таких випадках зазвичай використовується така функція, як memccpy(), яка копіює дані в буфер призначення з джерела, доки не буде знайдено вказаний символ. Розглянемо функцію:

void func(char *path)
{
char servaddr[40];
…
memccpy(servaddr,path,'\');
….
}

У цьому випадку інформація, що міститься в path, може бути більшою за 40 байт, перш ніж можна буде зустріти \. Якщо так, це призведе до переповнення стека. Аналогічна уразливість була виявлена в підсистемі Windows RPCSS (MS03-026). Вразливий код копіював імена серверів із UNC-шляхів у буфер фіксованого розміру, доки не зустрічався \. Довжина імені сервера в цьому випадку контролювалася користувачами.

Окрім ручного перегляду коду на наявність переповнень стека, інструменти статичного аналізу коду також можуть надати велику допомогу. Хоча вони, як правило, генерують багато хибних спрацьовувань і навряд чи можуть знайти невелику частину дефектів, вони, безумовно, допомагають зменшити накладні витрати, пов’язані з пошуком низьких результатів, таких як помилки strcpy() і sprintf(). Для аналізу мов у стилі C доступні різноманітні інструменти, такі як RATS, Flawfinder та ITS4.

